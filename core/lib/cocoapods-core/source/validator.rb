module Pod
  class Source

    # TODO: THIS CLASS IS A STUB

    # Checks whether a podspec can be accepted by a source.
    #
    # This class can work on Travis but some checks are lost as the repo is
    # already merged during the test.
    #
    class Validator

      # @return [Source] the source where the podspec should be added.
      #
      attr_reader :source

      # @param  [Pathname] repo @see Source#repo.
      #
      def initialize(repo)
        @source = Source.new(repo)
        @errors = {}
        @linter_results = {}
      end

      # @param  [Array<Pathname>] spec_paths
      #         a list of path that should be checked for being accepted in
      #         specs repo.
      #
      # @return [Bool] whether to podspec can be accepted by the source.
      #
      def check(spec_paths)
        spec_paths = [ spec_paths ] unless spec_paths.is_a?(Array)
        @errors = {}
        spec_paths.each do |path|
          @spec_path = Pathname.new(path)
          lint
          next unless spec
          # check_spec_path
          check_spec_source_change
          check_if_untagged_version_is_acceptable
          check_commit_change_for_untagged_version
          check_dependencies
        end
        errors.values.empty?
      end

      #-----------------------------------------------------------------------#

      # @!group Validation results

      public


      # @return [Hash{Pathname=>Array<String>}] the errors generated by the
      #         validation. If there is any error the podspec cannot be
      #         accepted.
      #
      attr_reader :errors

      # @return [Hash{Pathname=>Array<Specification::Linter::Result>}] the
      #         result generated by the linter for not approved specifications.
      #
      attr_reader :linter_results

      #-----------------------------------------------------------------------#

      # @!group Validation helpers

      private

      # @return [Pathname] The path of the current specification that should be
      #         checked.
      #
      attr_reader :spec_path

      # @return [Specification] The current specification that should be
      #         checked.
      #
      # @note   The specification is generated by the linter that catches any
      #         exception.
      #
      attr_reader :spec


      #
      #
      def error(message)
        @errors[spec_path] ||= []
        @errors[spec_path] << message
      end

      #-----------------------------------------------------------------------#

      # @!group Check steps

      private

      def lint
        linter = Specification::Linter.new(spec_path)
        if linter.lint
          @spec = linter.spec
        else
          error 'Linter failed validation.'
        end
      end

      # TODO: this check cannot be performed before a merge.
      # def check_spec_path
      #   expected = "#{spec.name}/#{spec.version}/#{spec.name}.podspec"
      #   relative_path = spec_path.relative_path_from(source.repo).to_s
      #   unless relative_path == expected
      #     error "Incorrect path, the path is `#{relative_path}` and should be `#{expected}`."
      #   end
      # end

      def check_spec_source_change
        return unless spec
        return unless reference_spec
        keys = Spec::DSL::SOURCE_KEYS.keys
        source = spec.source.values_at(*keys).compact.first
        old_source = reference_spec.source.values_at(*keys).compact.first
        unless source == old_source
          error "Attempt to change the source of the specification. " \
            "Source: `#{source}`. Previous: `#{old_source}`.\n " \
            "Contact specs repos maintainers if the library changed location."
        end
      end

      def check_if_untagged_version_is_acceptable
        return unless spec
        return if !spec.source[:git] || spec.source[:tag]

        # Allow to fix a 0.0.1 podspec
        if related_specifications && !related_specifications.any? { |s| s.version == '0.0.1' }
          error "There is already versioned specifications so " \
            "untagged versions cannot be added."
        elsif spec.version != Version.new('0.0.1')
          error "Untagged Git repositories should be versioned as 0.0.1"
        end
      end

      # TODO: this cannot be tested on Travis with the current setup
      def check_commit_change_for_untagged_version
        return unless spec
        return unless spec.version == Version.new('0.0.1')
        ref_spec = related_specifications.find { |s| s.version != '0.0.1' }
        return unless ref_spec
        unless ref_spec.source[:commit] == spec.source[:commit]
          error "Attempt to rewrite the commit of 0.0.1 version."
        end
      end

      def check_dependencies
        return unless spec
        spec.external_dependencies(true).each do |dep|
          set = source.search(dep)
          unless set && set.specification
            error "Unable to find a specification for the `#{dep}` dependency."
          end
        end
      end

      #-----------------------------------------------------------------------#

      # @!group Source helpers

      private

      def related_specifications
        versions = source.versions(spec.name)
        return unless versions
        specs = versions.sort.map { |v| source.specification(spec.name, v) }
        specs.reject { |s| s.defined_in_file == spec_path }
      end

      def reference_spec
        specs = related_specifications
        specs.last if specs
      end

    end
  end
end
